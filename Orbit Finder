% COPYRIGHT (C) 2023 [LAMBDA ANALYTICS LLC]. ALL RIGHTS RESERVED.
% THIS CODE IS THE PROPERTY OF LAMBDA ANALYTICS LLC AND IS PROTECTED UNDER COPYRIGHT LAWS.
% UNAUTHORIZED REPRODUCTION OR DISTRIBUTION OF THIS CODE, OR ANY PORTION OF IT, MAY RESULT IN SEVERE CIVIL AND CRIMINAL PENALTIES.

clear 
clc
format long


%=====HOUSKEEPING=====
%This program depends on 'CRTBP.m', 'BackwardCRTBP.m', 'Velocity.m',
%'librationPoints.m', 'jacobiConst.m', 'interpCrossingData.m', and 
%'CRTBPpoincareNewton.m'.

%This is desinged for looking at specific orbits read off the 
%Poincare map generated by 'Poincare_Sections.m'

%Determine a specific coordinate from the Poincare section to investigate.
%Match the energy level C with that of the section. Set the coordinates and
% user defined parameters, save the program, then run.


%=====PARAMETERS=====
G=1; % Gravitational constant (normalized)
m1= 0.98784635699194478508644579051179; %mass 1
m2= 0.012153643008053502741483420379609; %mass 2
m3= 0.0000000000000016540744733799014278142025561559; %mass 3
mu = (m2)/(m1 + m2); %mass ratio
R1 = 0.016573881373569198521833456538843; %radius of m1
R2 = 0.0028069719042663893171507538681908; %radius of m2
R3 = 0.0000023413111342351717924841966733673; %radius of m3
C1_20 = -0.00134; %oblateness of m1
C2_20 = -0.00040; %oblateness of m2
C3_20 = -1.7539838904324887014496425763355; %oblateness stanford torus
c1 = ((m3^(-2/3))*(R1^2)*(C1_20))/2; %radius scaling for m1
c2 = ((m3^-(2/3))*(R2^2)*(C2_20))/2; %radius scaling for m2
c3 = ((m3^-(2/3))*(R3^2)*(C3_20))/2; %radius scaling for m3
C1 = (R1^2)*(C1_20)/2;
C2 = (R2^2)*(C2_20)/2;
C3 = (R3^2)*(C3_20)/2;
C12 = C1+C2;
C23 = C2+C3;
C13 = C1+C3;

% Compute normalized distances and positions using the defined constants
omega = sqrt(1 - 3*C12);
f = @(u) (1/u)^3 - 3*C13/u^5 - omega^2;
u = fzero(f,1); %m1-m3 normalized distance
f = @(v) (1/v)^3 - 3*C23/v^5 - omega^2;
v = fzero(f,1); %m2-m3 normalized distance
w = 1 + u^2 - v^2;

% Compute positions of the three bodies in the coordinate system
x1 = -sqrt(m2^2+w*m2*m3+u^2*m3^2);
y1 = 0;
x2 = (-2*m2^2-2*u^2*m3^2-2*w*m2*m3+2*m2+w*m3)/(2*sqrt(m2^2+w*m2*m3+u^2*m3^2));
y2 = -(0.5)*sqrt((m3^2*(4*u^2-w^2))/(m2^2+w*m2*m3+u^2*m3^2));
x3 = (-2*m2^2-2*u^2*m3^2-2*w*m2*m3+w*m2+2*u^2*m3)/(2*sqrt(m2^2+w*m2*m3+1^2*m3^2));
y3 = (0.5)*sqrt((m2^2*(4*u^2 - w^2))/(m2^2+w*m2*m3+u^2*m3^2));

% Compute eigenvalues using the positions and constants
Delta = (mu*u^3+(1-mu)*v^3)^2-mu*(1-mu)*u*v*(-u^4-v^4+2*u^2+2*v^2+2*u^2*v^2-1);
lambda1 = 0.5*(2-(2*(1-mu))/u^5-(2*mu)/v^5+(3*(1-mu))/u^3+(3*mu)/v^3-3/(u^3*v^3)*sqrt(Delta)); %eigen 1
lambda2 = 0.5*(2-(2*(1-mu))/u^5-(2*mu)/v^5+(3*(1-mu))/u^3+(3*mu)/v^3+3/(u^3*v^3)*sqrt(Delta)); %eigen 2

%Compute libration points
[L1, L2, L3, L4, L5, L6] = librationPoints(mu, u, v, c1, c2, c3, lambda1, lambda2);

%Compute the energy at each libration point
CL3 = jacobiConst(L3, mu, c1, c2, c3, lambda1, lambda2, u, v);
CL1 = jacobiConst(L1, mu, c1, c2, c3, lambda1, lambda2, u, v);
CL2 = jacobiConst(L2, mu, c1, c2, c3, lambda1, lambda2, u, v);
CL4 = jacobiConst(L4, mu, c1, c2, c3, lambda1, lambda2, u, v);
%CL5=CL4 so no extra computation is needed

% Define the Hamiltonian function for the system
Hamiltonian_scalar = @(x, y, Px, Py) (0.5)*(Px^2 + Py^2) + y*Px - x*Py ...
    + x^2*((1-lambda2)/2) + y^2*((1-lambda1)/2) + (c1*(1-mu)/u^3) + (mu*c2/v^3) ...
    - 1/sqrt(x^2+y^2) + c3/sqrt(x^2+y^2)^3;

% Set initial conditions for the Hamiltonian computation
x = x3; y = y3; Px = -y; Py = 35+x;

C = Hamiltonian_scalar(x,y,Px,Py)

%Set coordinates of Poincare section to be investigated
poincare_x = x3;
poincare_y = y3;

%Determines how many crossings of the xz-plane will be
%computed for every initial condition
iterates = 400;


%=====COMPUTATIONS=====

%Initial Positions. Should match 'Poincare_Section'
x0 = poincare_x;
y0 = 1e-16;
z0 = 0;

%Compute velocity
V = Velocity([x0; y0; z0],C, mu,lambda2,lambda1,c1,c2,c3,u,v);

v_x0 = poincare_y; %Direction of velocity in 'Poincare_Section'
v_y0 = sqrt(V^2 - v_x0^2);
v_z0 = 0.0;
v0 = [v_x0; v_y0; v_z0];

u_v = v0/norm(v0); %make velocity a unit vector

xdot0 = V*u_v(1,1); %=0
ydot0 = V*u_v(2,1); %=V
zdot0 = V*u_v(3,1); %=0

%Initial condition vector
y0 = [x0; y0; z0; xdot0; ydot0; zdot0];

%Determine how many initial conditions. Only k=1 needed here
k = 1;

%Sets the left endpoint for points to be itterated.
x_begin = poincare_x;

%Determines how far to go to the right of 'x_begin'
x_end = x_begin;

%=====Main Loops=====

%The following parameters do not need to be changed

%Tolerence for the map
epsilon = 1e-6;

%Time step
timeStep = 10;

%INITIALIZE:
x_nIterates = 0;
totalIterates = 0;
initial_n = 0;
checkWhile = 0;
lastPath = 0;
pathTime = 0;
interpTimes = 0;
ReIntegrate = 0;
checkTotal = 0;
calledNewton = 0;
tf = 0;

for n = 1:k

    check_n = n; %Displays current loop
    checkTotal = totalIterates;

    initial_n = y0';

    x_nIterates = 0;   

    %Begining of while loop
    while x_nIterates <iterates

        %Integrate for this time interval
        tspan = [0 timeStep];
        options = odeset('RelTol',1e-13,'AbsTol',1e-13);     %set tolerences

        %numerical integration        
        [t, trajectory_n] = ode78('vectorField',tspan,initial_n,options,[],c3,lambda1,lambda2);

        temp = size(trajectory_n);
        numSteps = temp(1,1);

        %keep track of the trajectory up to now
        path(lastPath+1:lastPath+numSteps, 1:6) = trajectory_n(1:numSteps,1:6);
        pathTime(lastPath+1:lastPath+numSteps) = timeStep*(checkWhile-1)*ones(1,numSteps)+t(numSteps);

        checkWhile = checkWhile+1

        temp2 = size(path); %Keep track of how much is in path up to now
        lastPath = temp2(1,1);

        %Check for pairs of points along the trajectory between which
        %the sign of y changes and the sign of ydot is positive
        for i = 2:numSteps

            %Check for sign change of y and correct sign of ydot

            if (sign(trajectory_n(i,2)) ~= sign(trajectory_n(i-1,2))) && (trajectory_n(i,5) > 0)

                %Check if already a crossing to the desired tolerence
                if (abs(trajectory_n(i-1,2))<epsilon)
                    intersection=trajectory_n(i-1,:);
                elseif (abs(trajectory_n(i,2))<epsilon)
                    intersection=trajectory_n(i,:);
                else
       
                    %Newton method determines the crossing to the desired
                    %accuracy if neither of the points for which the sign 
                    %change occurs are in tolerence
                    intersection = Trajectory_Crossing(t(i-1),trajectory_n(i-1,:),t(i),trajectory_n(i,:),epsilon,mu,c3,lambda1,lambda2);
                    calledNewton = calledNewton+1; 

                end 

                %Keep track of how many iterates have been found
                x_nIterates = x_nIterates+1;  

                %Keep track of total number intersections have been found
                totalIterates = totalIterates+1 

                %Store intersection information for plotting later
                PoincareMap(totalIterates, 1) = intersection(1);
                PoincareMap(totalIterates, 2) = intersection(4);

            end

        end 

        initial_n=trajectory_n(numSteps,:);
        tf=t(numSteps)+tf

    end

end  


%=====Plotters=====
figure
plot(path(:,1), path(:,2), 'b')
axis square

hold on

plot(0,0,'ko','MarkerSize',10,'MarkerFaceColor', 'red')
legend('Trajectory','Target', '','Target')

